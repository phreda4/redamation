#include "stdafx.h"
#include "graficos.h"
#include "charlist.h"
#include "aygshell.h"

BufferGrafico Pantalla;	// doble buffer

ColorRGBA colornegro={0,0,0,255,0};
ColorRGBA colorblanco={255,255,255,255,0xffff};

void BufferGrafico::redraw()
{
void *pBuffer = GXBeginDraw();
memcpy(pBuffer,Buffer,SIZESCREEN);
GXEndDraw();
}

void BufferGrafico::toBuff(void *p)
{
memcpy(Buffer,p,SIZESCREEN);
}

void BufferGrafico::fromBuff(void *p)
{
memcpy(p,Buffer,SIZESCREEN);
}

CNativeBitmap* BufferGrafico::CreateNativeBitmap(HBITMAP hBitmap)
{
if (hBitmap == NULL) return NULL;
CNativeBitmap* pBitmap = new CNativeBitmap(); // caller is responsible to delete
if (pBitmap == NULL) return NULL;
HBITMAP hResultBitmap;
BGRColor* pDIBits=GetDIBits(hBitmap, pBitmap->m_size, hResultBitmap);
pBitmap->m_pBits=CreateNativeBitmapFromBGRBits(pBitmap->m_size.cx, pBitmap->m_size.cy, pDIBits);
::DeleteObject(hResultBitmap);
return pBitmap;
}


CNativeBitmap* BufferGrafico::loadBitmap(char *filename)
{
HBITMAP bb;
TCHAR name[255];
wsprintf(name,_T("%hs"),filename);// de char a charw
bb=SHLoadImageFile(name);
CNativeBitmap* pBitmap=CreateNativeBitmap(bb);
::DeleteObject(bb);
return pBitmap;
}

BOOL BufferGrafico::InternalBlt(int nDestX, int nDestY, int nWidth, int nHeight, const CNativeBitmap* pNativeBitmap, int nSrcX, int nSrcY, DWORD dwTranspNativeColor)
{// check for incorrect parameters
if (Buffer==NULL || pNativeBitmap==NULL || pNativeBitmap->m_pBits==NULL || nWidth<=0 || nHeight<=0 || nSrcX<0 || nSrcY<0)
	return FALSE;
/*
// check if the bitmap is large enough
if (nSrcX+nWidth>pNativeBitmap->GetBitmapSize().cx || nSrcY+nHeight>pNativeBitmap->GetBitmapSize().cy)
	return FALSE;
*/
// check if there is nothing to draw
if (nDestX>(int) disp.cxWidth || nDestY>(int) disp.cyHeight) return TRUE;
// check boundaries and crop if necessary
if (nDestX < 0)	{nWidth += nDestX;nSrcX -= nDestX;nDestX = 0;}
if (nDestY < 0)	{nHeight += nDestY;nSrcY -= nDestY;nDestY = 0;}
if (nWidth > (int)disp.cxWidth - nDestX){nWidth=disp.cxWidth - nDestX;}
if (nHeight>(int)disp.cyHeight - nDestY){nHeight=disp.cyHeight - nDestY;}
WORD* pdestline = Buffer;// transfer bits
pdestline += nDestX * XPitch + nDestY * YPitch;
WORD* psrcline = (WORD*) pNativeBitmap->m_pBits;
psrcline += nSrcX + nSrcY * pNativeBitmap->m_size.cx;
// transparent color should not decrease perfomance
// if it is not specified
if (dwTranspNativeColor == 0xffff)
	{
	for (int y=0;y<nHeight;y++)
		{
		WORD* pdest = pdestline;
		WORD* psrc = psrcline;
		for (int x=0;x<nWidth;x++)
			{*pdest = *psrc;pdest += XPitch;psrc++;}
		pdestline += YPitch;psrcline += pNativeBitmap->m_size.cx;
		}
	}
else
	{
	for (int y=0;y<nHeight;y++)
		{
		WORD* pdest = pdestline;
		WORD* psrc = psrcline;
		for (int x=0;x<nWidth;x++)
			{
			if (*psrc!=dwTranspNativeColor)
				{*pdest=*psrc;}
			pdest +=XPitch;psrc++;
			}
		pdestline +=YPitch;
		psrcline += pNativeBitmap->m_size.cx;
		}
	}
return true;
}


void BufferGrafico::MaskedBlt(int nDestX, int nDestY, int nWidth, int nHeight, const CNativeBitmap* pNativeBitmap, const CNativeBitmap* pNativeMask, int nSrcX /*=0*/, int nSrcY /*=0*/)
{
/*
// check for incorrect parameters
if (Buffer==NULL || pNativeBitmap==NULL || pNativeBitmap->m_pBits==NULL || nWidth<=0 || nHeight<=0 || nSrcX<0 || nSrcY<0)
	return;
// the mask should have the same size as the bitmap
if (pNativeBitmap->GetBitmapSize().cx != pNativeMask->GetBitmapSize().cx || pNativeBitmap->GetBitmapSize().cy != pNativeMask->GetBitmapSize().cy)
	return;
// check if the bitmap is large enough
if (nSrcX + nWidth > pNativeBitmap->GetBitmapSize().cx || nSrcY + nHeight > pNativeBitmap->GetBitmapSize().cy)
	return;
*/
// check if there is nothing to draw
if (nDestX > (int)disp.cxWidth || nDestY > (int)disp.cyHeight)	return;
// check boundaries and crop if necessary
if (nDestX < 0)	{nWidth += nDestX;nSrcX -= nDestX;nDestX = 0;}
if (nDestY < 0)	{nHeight += nDestY;nSrcY -= nDestY;nDestY = 0;}
if (nWidth > (int) disp.cxWidth - nDestX){nWidth = disp.cxWidth - nDestX;}
if (nHeight > (int) disp.cyHeight - nDestY){nHeight = disp.cyHeight - nDestY;}
WORD* pDestLine =Buffer;// transfer bits
pDestLine += nDestX *XPitch + nDestY *YPitch;
WORD* pSrcLine = (WORD*) pNativeBitmap->m_pBits;
pSrcLine += nSrcX + nSrcY * pNativeBitmap->m_size.cx;
WORD* pMaskLine = (WORD*) pNativeMask->m_pBits;
pMaskLine += nSrcX + nSrcY * pNativeMask->m_size.cx;
for (int y = 0; y < nHeight; y++)
	{
	WORD* pDest = pDestLine;
	WORD* pSrc = pSrcLine;
	WORD* pMask = pMaskLine;
	for (int x = 0; x < nWidth; x++)
		{
		if (*pMask > 0)	*pDest = *pSrc;
		pDest +=XPitch;pSrc++;pMask++;
		}
	pDestLine +=YPitch;
	pSrcLine += pNativeBitmap->m_size.cx;
	pMaskLine += pNativeMask->m_size.cx;
	}
}

WORD* BufferGrafico::CreateNativeBitmapFromBGRBits(int nWidth, int nHeight,const BGRColor *pDIBits)
{
if (pDIBits == NULL || nWidth < 1 || nHeight < 1)return NULL;
int nCorrectedWidth = ((nWidth + 3) / 4 ) * 4;
WORD* pNativeBuffer = new WORD[nWidth*nHeight];
WORD* pDest = pNativeBuffer;
for (int y = 0; y < nHeight; y++)
	{
	const BGRColor* pSrc = pDIBits + nCorrectedWidth*(nHeight-y-1);
	for (int x = 0; x < nWidth; x++)
		{
		*pDest = Get16bppColor(RGB(pSrc->m_R, pSrc->m_G, pSrc->m_B));
		pDest++;pSrc++;
		}
	}
return pNativeBuffer;
}

BGRColor* BufferGrafico::GetDIBits(HBITMAP hBitmap, SIZE& size, HBITMAP& hResultBitmap)
{
// Getting bimap size
BITMAP bm;
GetObject(hBitmap, sizeof(BITMAP), &bm);
// Creating new bitmap and receive pointer to it's bits.
HBITMAP hTargetBitmap;
void *pBuffer;
int nCorrectedWidth = ((bm.bmWidth + 3) / 4 ) * 4;
// Initilize DIBINFO structure
DIBINFO  dibInfo;
dibInfo.bmiHeader.biBitCount = 24;
dibInfo.bmiHeader.biClrImportant = 0;
dibInfo.bmiHeader.biClrUsed = 0;
dibInfo.bmiHeader.biCompression = 0;
dibInfo.bmiHeader.biHeight = bm.bmHeight;
dibInfo.bmiHeader.biPlanes = 1;
dibInfo.bmiHeader.biSize = 40;
dibInfo.bmiHeader.biSizeImage = nCorrectedWidth*bm.bmHeight*3;
dibInfo.bmiHeader.biWidth = nCorrectedWidth;
dibInfo.bmiHeader.biXPelsPerMeter = 3780;
dibInfo.bmiHeader.biYPelsPerMeter = 3780;
dibInfo.bmiColors[0].rgbBlue = 0;
dibInfo.bmiColors[0].rgbGreen = 0;
dibInfo.bmiColors[0].rgbRed = 0;
dibInfo.bmiColors[0].rgbReserved = 0;
// Create bitmap and receive pointer to points into pBuffer
HDC hDC = ::GetDC(NULL);
ASSERT(hDC);
hTargetBitmap = ::CreateDIBSection(hDC,(const BITMAPINFO*)dibInfo,DIB_RGB_COLORS,(void**)&pBuffer,NULL,0);
::ReleaseDC(NULL, hDC);
// Copy source bitmap into the target bitmap.
// Create 2 device contexts 
HDC hMemDc = ::CreateCompatibleDC(NULL);
HDC hTargetDc = ::CreateCompatibleDC(NULL);
// Select source bitmap into one DC, target into another
HBITMAP hOldBitmap1 = (HBITMAP) ::SelectObject(hMemDc, hBitmap);
HBITMAP hOldBitmap2 = (HBITMAP) ::SelectObject(hTargetDc, hTargetBitmap);
// Copy source bitmap into the target one
::BitBlt(hTargetDc, 0, 0, bm.bmWidth, bm.bmHeight, hMemDc, 0, 0, SRCCOPY);
// Restore device contexts
::SelectObject(hMemDc, hOldBitmap1);
::SelectObject(hTargetDc, hOldBitmap2);
::DeleteDC(hMemDc);
::DeleteDC(hTargetDc);
	// Here we can bitmap bits: pBuffer. Note:
	// 1. pBuffer contains 3 bytes per point
	// 2. Lines ane from the bottom to the top!
	// 3. Points in the line are from the left to the right
	// 4. Bytes in one point are BGR (blue, green, red) not RGB
	// 5. pBuffer will be automatically deleted 
	//    when delete hTargetBitmap
hResultBitmap = hTargetBitmap;
size.cx = bm.bmWidth;
size.cy = bm.bmHeight;
return (BGRColor*) pBuffer;
}

void BufferGrafico::InitDisplayProps()
{
disp=GXGetDisplayProperties();
XPitch =disp.cbxPitch >> 1;
YPitch =disp.cbyPitch >> 1;
if (XPitch < 0)
	BufferStartOffset =XPitch * (disp.cxWidth - 1);
else
	BufferEndOffset =XPitch * (disp.cxWidth - 1);
if (YPitch < 0)
	BufferStartOffset +=YPitch * (disp.cyHeight - 1);
else
	BufferEndOffset +=YPitch * (disp.cyHeight - 1);
if (disp.ffFormat | kfDirect565) 
	{ 
	RedD=11;GreenD=6;RED_MASK=0xF800;GREEN_MASK=0x07E0;BLUE_MASK=0x001F;
	}
else if (disp.ffFormat | kfDirect555) 
	{ 
	RedD=10;GreenD=5;RED_MASK=0xFC00;GREEN_MASK=0x03E0;BLUE_MASK=0x001F;
	}
if (Buffer != NULL || disp.cBPP != 16) return;
m_pMemoryBuffer = new WORD[BufferEndOffset - BufferStartOffset + 1];
if (m_pMemoryBuffer == NULL) return;
Buffer = (WORD*) m_pMemoryBuffer - BufferStartOffset;
// subventana
wp=(short)disp.cxWidth;hp=(short)disp.cyHeight;
// poligonos
linact=seg;
memset(lines,0,MAXLINES*sizeof(Segmento *));
limymin=MAXLINES;limymax=-1;
// color negro sin alpha
Alpha(255);
Color(0x0);
}

// rutinas graficas
void (*_spixel)(BufferGrafico *bg);
void (*_spixela)(BufferGrafico *bg,byte a);

// color solido
void _spixeld(BufferGrafico *bg) 
{
*(bg->m_pCurrentPos)=bg->color.directo; 
}
void _spixelda(BufferGrafico *bg,byte a) 
{
*(bg->m_pCurrentPos)=bg->mix_alpha(*(bg->m_pCurrentPos),bg->color.directo,a); 
}
// dibujo solido con alpha
void _spixelaa(BufferGrafico *bg)
{ 
*(bg->m_pCurrentPos)=bg->mix_alpha(*(bg->m_pCurrentPos),bg->color.directo,bg->alpha); 
}
void _spixelaaa(BufferGrafico *bg,byte a)
{ 
WORD ar=(a+bg->alpha)>>1;
*(bg->m_pCurrentPos)=bg->mix_alpha(*(bg->m_pCurrentPos),bg->color.directo,(byte)ar); 
}
// 
void _spixelx(BufferGrafico *bg)
{ 
*(bg->m_pCurrentPos)^=bg->color.directo; 
}
void _spixelxa(BufferGrafico *bg,byte a)
{ 
}
// rutinas basicas
void BufferGrafico::ClrScr(void)
{
register WORD *pp=Buffer;
for (register int i=0;i<=Pantalla.BufferEndOffset;i++,pp++)
  *pp=color.directo;
}

void BufferGrafico::VLine(short x1,short y1,short y2)
{
if (y1>y2) { short tmp;tmp=y1;y1=y2;y2=tmp; }
if (x1<0 || x1>=wp || y2<0 || y1>=hp) return;
if (y1<0) y1=0;
if (y2>=hp) y2=hp-1;
SetPos(x1,y1);
register WORD cnt=y2-y1+1;
while (cnt>0) {
	SPixel();IncYPos();cnt--;
	}
}

void BufferGrafico::HLine(short x1,short y1,short x2)
{
if (x1>x2) { short tmp;tmp=x1;x1=x2;x2=tmp; }
if (x2<0 || x1>=wp || y1<0 || y1>=hp) return;
if (x1<0) x1=0;
if (x2>=wp) x2=wp-1;
SetPos(x1,y1);
register WORD cnt=x2-x1+1;
while (cnt>0) {
	SPixel();IncXPos();cnt--;
	}
}

void BufferGrafico::HLineD(int x1,int y1,int x2,ColorRGBA &c1,ColorRGBA &c2)
{
int cnt=x2-x1+1;
int r=c1.r,g=c1.g,b=c1.b;
r<<=8;g<<=8;b<<=8;
int dr=c2.r-c1.r,dg=c2.g-c1.g,db=c2.b-c1.b;
dr<<=8;dg<<=8;db<<=8;
dr/=cnt;dg/=cnt;db/=cnt;
short x=x1;
for (register int i=0;i<cnt;i++,x++)
	{
	ColorRGB(r>>8,g>>8,b>>8);
	SetPixel(x,y1);
	r+=dr;g+=dg;b+=db;
	}
}

void BufferGrafico::VLineD(int x1,int y1,int y2,ColorRGBA &c1,ColorRGBA &c2)
{
}

void BufferGrafico::AALine(WORD x1,WORD y1,WORD x2,WORD y2)
{
int dx,dy,sx,sy,d;
WORD ea;
BYTE ci;
if (x1==x2) {VLine(x1,y1,y2);return;}
if (y1==y2) {HLine(x1,y1,x2);return;};
dx=x2-x1;dy=y2-y1;
if (dx>0) sx=1; else { sx=-1;dx=-dx;}
if (dy>0) sy=1; else { sy=-1;dy=-dy;}
WORD ec=0;
SetPos(x1,y1);SPixel();
if (dy>dx) 
	{
	ea=(dx<<16)/dy;
    while (dy>0) 
		{
        dy--;d=ec;ec+=ea;
        if (ec<=d) x1+=sx;
        y1+=sy;ci=ec>>8;
		SetPos(x1,y1);SPixelA(255-ci);XPos(sx);SPixelA(ci);
		}
	}
else // DY <= DX
	{
    ea=(dy<<16)/dx;
    while (dx>0)
		{
        dx--;d=ec;ec+=ea;
        if (ec<=d) y1+=sy;
        x1+=sx;ci=ec>>8;
		SetPos(x1,y1);SPixelA(255-ci);YPos(sy);SPixelA(ci);
		}
	}
}


void BufferGrafico::SPlineIter(long x1,long y1,long x2,long y2,long x3,long y3)
{
if (recta(x1,y1,x2,y2,x3,y3)<1024)
	{
	Line(x1>>4,y1>>4,x3>>4,y3>>4);
	return;
	}
long x11=(x1+x2)>>1,y11=(y1+y2)>>1;
long x21=(x2+x3)>>1,y21=(y2+y3)>>1;
long x22=(x11+x21)>>1,y22=(y11+y21)>>1;
SPlineIter(x1,y1,x11,y11,x22,y22);
SPlineIter(x22,y22,x21,y21,x3,y3);
}

void BufferGrafico::pSegmento(int x1,int y1,int x2,int y2)
{
Segmento *s;
int dx,x,ymin,ymax;
int temp;
if (y1==y2) return;
if (y1<y2) 
	{
    ymin=y1;ymax=y2;
	} 
else 
	{
    ymin=y2;ymax=y1;
	temp=x2;x2=x1;x1=temp;
    }
if (ymax<0 || ymin>=hp) return;//
x=x1<<SEGFRAC;
dx=((x2-x1)<<SEGFRAC)/(ymax-ymin);
if (ymin<0) { x+=dx*(-ymin);ymin=0; }
//if (ymax>hp) ymax=hp+1;// hasta la ultima linea
if (ymax>=hp) ymax=hp;// hasta la ultima linea
s=allocS();
if (s==NULL) return;
s->next=s->nextValid=0;
s->ymax=ymax;
s->x=x;
s->dx=dx;
if (ymin<limymin) limymin=ymin;
if (ymax>limymax) limymax=ymax;
if (lines[ymin]==NULL) 
	lines[ymin]=s;
else 
	{
    Segmento *act,*prev;
    prev=0;
    for(act=lines[ymin];act;prev=act,act=act->next) 
		{
        if ((act->x+act->dx)>(s->x+s->dx)) 
			{
            if (prev) 
				{
                prev->next=s;
                s->next=act;
                } 
			else 
				{
                s->next=lines[ymin];
                lines[ymin]=s;
                }
            break;
            }
        }
	if (act==0) 
		{
        prev->next=s;
        s->next=act;
        }
    }
}

void BufferGrafico::pSPlineIter(long x1,long y1,long x2,long y2,long x3,long y3)
{
if (recta(x1,y1,x2,y2,x3,y3)<1024)
	{
	pSegmento(x1>>4,y1>>4,x3>>4,y3>>4);
	return;
	}
long x11=(x1+x2)>>1,y11=(y1+y2)>>1;
long x21=(x2+x3)>>1,y21=(y2+y3)>>1;
long x22=(x11+x21)>>1,y22=(y11+y21)>>1;
pSPlineIter(x1,y1,x11,y11,x22,y22);
pSPlineIter(x22,y22,x21,y21,x3,y3);
}


Segmento *BufferGrafico::avanzaS(Segmento *curSegs,int y)
{
Segmento *s,*prev,*ant;
s=curSegs;
prev=ant=0;
while(s)
    {
    if (y>=s->ymax) // == para evitar superpuestos
		{
        if (prev)         // Remove this segment, no more valid
			prev->nextValid=s->nextValid;
		else 
			curSegs=s->nextValid;
        s=s->nextValid;
        } 
	else 
		{
		s->x+=s->dx;
		if (prev!=0 && s->x<prev->x) // se invirtio el orden
			{
			if (ant==0) curSegs=s;// es el primero
			else ant->nextValid=s;// intercambiar prev y seg
			prev->nextValid=s->nextValid;
			s->nextValid=prev;ant=s;s=prev->nextValid;
			}
		else  // sigue igual
			{
			ant=prev;prev=s;s=s->nextValid;
			}
        }
    }
return curSegs;
}

Segmento *BufferGrafico::nuevoS(Segmento *curSegs,Segmento *newSegs)
{
Segmento *s,*se,*prev;
s=curSegs;
prev=0;
for (se=newSegs;se;se=se->next)// Check for new segments
    {
	if (curSegs==0)// Place it at the correct position according to X
		{
        curSegs=se;
        se->nextValid=0;
        } 
	else 
		{
        for(;s;prev=s,s=s->nextValid)
            {
            if (s->x>se->x)
				{
                if (prev)  // Insert before s
					{
                    se->nextValid=s;
                    prev->nextValid=se;
                    } 
				else 
					{
                    se->nextValid=curSegs;
                    curSegs=se;
                    }
                break;
                }
            }
		if (s==0) // Append at the end
			{
            prev->nextValid=se;
            se->nextValid=0;
            }
        }
    s=se;
    }
return curSegs;
}

// Poligonos con antialiasing
void BufferGrafico::Flinea(int y,int x1,int x2,int x3,int x4)
{
if (x2>x3) { x2=x3;if (x1>x2) x1=x2; }
if (x1<0) x1=0;
if (x2<0) x2=0;
//if (x2>x3) { int t=x2;x2=x3;x3=t;}
int ex1=x1>>SEGFRAC,ex2=x2>>SEGFRAC;
int ex3=x3>>SEGFRAC,ex4=x4>>SEGFRAC;
int fx1=x1&MASFRAC,fx2=x2&MASFRAC;
int fx3=x3&MASFRAC,fx4=x4&MASFRAC;
if (ex4<0 || ex1>=wp) return;
register int n;
SetPos(ex1,y);
// 1er degrade
if (ex1==ex2)
	{
	if (ex2!=ex3) 
		{
		SPixelA(255-((fx1+fx2)>>1));
		IncXPos();
		}
	else// ex3 esta en el mismo pixel que ex2
		{
		int f1=(fx1+fx2)>>1,f2=(fx3+fx4)>>1;
		if (ex3==ex4) // estan todos en el mismo pixel
			{
			SPixelA((f1>f2)?f1-f2:f2-f1);
			return;
			}
		else //x4 esta mas adelante
			{
			SPixelA((f1>f2)?f1:f2);
			IncXPos();
			}
		}
	}
else
	{
	n=ex2-ex1;
	int alpha=0;// el comienzo puede no ser 0
	int da=((255-alpha)<<8)/n;
	if (ex2>=wp) 
		{
		ex2=wp-1;
		n=ex2-ex1;
		}
	n++;
	while (n--) 
		{ 
		SPixelA(alpha>>8);
		IncXPos();
		alpha+=da;
		}
	}
// relleno
if (ex3>=wp) ex3=wp-1;// llego al fin
n=ex3-ex2;//-1
if (n>0)
	{
	while (n--)
		{
		SPixel();
		IncXPos();
		}
	}
// 2do degrade
if (ex3==wp) return;
if (ex3==ex4)
	{SPixelA((fx3+fx4)>>1);}
else
	{
	n=ex4-ex3;//+1;
	int alpha=255<<8;
	int da=((0-255)<<8)/n;
	if (ex4>=wp) n=wp-ex3-1;// hasta el final
	while (n--) 
		{ 
		SPixelA(alpha>>8);
		IncXPos();
		alpha+=da;
		}
	}
}

//**************************************************
//***** DIBUJO DE POLIGONO
//**************************************************
void BufferGrafico::drawPoli(void)
{
int x1,x2,x3,x4,t;
Segmento *curSegs,*s;
if (limymax==-1) return;
//if (limymax>hp) limymax=hp;
curSegs=NULL;
for(unsigned short y=limymin;y<limymax;y++) 
	{
    curSegs=avanzaS(curSegs,y);
    curSegs=nuevoS(curSegs,lines[y]);
	for(s=curSegs;s && s->nextValid;s=s->nextValid)
	    {
		if (s->nextValid->x<0) { s=s->nextValid;continue; } // anteriores a la pantalla
	    if (s->x>(wp<<SEGFRAC)) break; //siguientes de la pantalla
		x1=s->x;x2=s->x+s->dx;
		if (s->dx<0) {t=x1;x1=x2;x2=t;}
		s=s->nextValid;
		x3=s->x;x4=s->x+s->dx;
		if (s->dx<0) {t=x3;x3=x4;x4=t;}	
		Flinea(y,x1,x2,x3,x4);
	    }
    }
memset(&lines[limymin],0,(limymax-limymin+1)*sizeof(Segmento *));
limymax=-1;
limymin=hp+1;
linact=seg;
}

void BufferGrafico::drawLines(void)
{
int x,dx,x1,x2,x3,x4,t;
Segmento *curSegs,*s;
if (limymax==-1) return;
//if (limymax>hp) limymax=hp;
curSegs=NULL;
for(unsigned short y=limymin;y<limymax;y++) 
	{
    curSegs=avanzaS(curSegs,y);
    curSegs=nuevoS(curSegs,lines[y]);
	for(s=curSegs;s;s=s->nextValid)
	    {
		if (s->x<0) continue; // anteriores a la pantalla
	    if (s->x>(wp<<SEGFRAC)) break; //siguientes de la pantalla
		x=s->x;dx=s->x+s->dx;
		if (s->dx<0) {t=x;x=dx;dx=t;}
		x1=x-(1<<SEGFRAC);x2=dx-(1<<SEGFRAC);
		x3=x+(1<<SEGFRAC);x4=dx+(1<<SEGFRAC);
		/*
		s=s->nextValid;
		x3=s->x;x4=s->x+s->dx;
		if (s->dx<0) {t=x3;x3=x4;x4=t;}	
*/
		Flinea(y,x1,x2,x3,x4);
	    }
    }
memset(&lines[limymin],0,(limymax-limymin+1)*sizeof(Segmento *));
limymax=-1;
limymin=hp+1;
linact=seg;
}

void BufferGrafico::drawShape(void)
{
//ordenar lineas a pintar

// buscar primera linea

// iterar por cada linea

// pintar linea
}

// basicos
bool BufferGrafico::ClipLine(int *X1,int *Y1,int *X2,int *Y2)
{
int C1,C2;
int V;
if (*X1<0) C1=1; else C1=0;
if (*X1>=wp) C1|=0x2;
if (*Y1<0) C1|=0x4;
if (*Y1>=hp) C1|=0x8;
if (*X2<0) C2=1; else C2=0;
if (*X2>=wp) C2|=0x2;
if (*Y2<0) C2|=0x4;
if (*Y2>=hp) C2|=0x8;
if ((C1&C2)==0 && (C1|C2)!=0) 
	{
	if ((C1&12)!=0)
		{
		if (C1<8) V=0; else V=hp-1;
		*X1+=(V-*Y1)*(*X2-*X1)/(*Y2-*Y1);
		*Y1=V;
		if (*X1<0) C1=1; else C1=0;
		if (*X1>=wp) C1|=0x2;
		}
    if ((C2&12)!=0)
		{
		if (C2<8) V=0; else V=hp-1;
		*X2+=(V-*Y2)*(*X2-*X1)/(*Y2-*Y1);
		*Y2=V;
		if (*X2<0) C2=1; else C2=0;
		if (*X2>=wp) C2|=0x2;
		}
    if ((C1&C2)==0 && (C1|C2)!=0) 
		{
		if (C1!=0)
			{
			if (C1==1) V=0; else V=wp-1;
			*Y1+=(V-*X1)*(*Y2-*Y1)/(*X2-*X1);
			*X1=V;C1=0;
			}
		if (C2!=0)
			{
			if (C2==1) V=0; else V=wp-1;
			*Y2+=(V-*X2)*(*Y2-*Y1)/(*X2-*X1);
			*X2=V;C2=0;
			}
		}
	}
return (C1|C2)==0;
}

void BufferGrafico::Line(int x1,int y1,int x2,int y2)
{
if (ClipLine(&x1,&y1,&x2,&y2)) AALine(x1,y1,x2,y2);
}

void BufferGrafico::FLine(int x1,int y1,int x2,int y2,WORD t)
{
if (!ClipLine(&x1,&y1,&x2,&y2)) return;
int dx,dy,xinc,yinc,s,dx2,dy2,dxy,x,y;
if (x1<x2) xinc=1; else xinc=-1;
dx=abs(x1-x2);
if (y1<y2) yinc=1; else yinc=-1;
dy=abs(y1-y2);
dx2=dx+dx;dy2=dy+dy;
x=x1;y=y1;
WORD mask=0x2;
if ((t&1)!=0) SetPixelF(x,y);
if (dx>dy)
	{
	s = dy2 - dx;
	dxy = dy2 - dx2;
	for (int i=1;i<dx+1;i++)
		{
		if (s>=0) { y+=yinc;s+=dxy; }	else s+=dy2;
		x+=xinc;
		if ((t&mask)!=0) SetPixelF(x,y);
		if (mask==0x8000) mask=0x1; else mask<<=1;
		}
	}
else
	{
	s = dx2 - dy;
	dxy = dx2 - dy2;
	for (int i=1;i<dy+1;i++)
		{
		if (s>=0) { x+=xinc;s+=dxy; }	else s+=dx2;
		y+=yinc;
		if ((t&mask)!=0) SetPixelF(x,y);
		if (mask==0x8000) mask=0x1; else mask<<=1;
		}
	}
}

void BufferGrafico::Box(int x1,int y1,int x2,int y2)
{
int t;
if (y1>y2) { t=y1;y1=y2;y2=t; } // y1 arriba
if (x1>x2) { t=x1;x1=x2;x2=t; } // x1 a la izq
VLine(x1,y1+1,y2-1);VLine(x2,y1+1,y2-1);
HLine(x1,y1,x2);HLine(x1,y2,x2);
}

void BufferGrafico::FillBox(int x1,int y1,int x2,int y2)
{
int t;
if (y1>y2) { t=y1;y1=y2;y2=t; } // y1 arriba
if (x1>x2) { t=x1;x1=x2;x2=t; } // x1 a la izq
if (x2<0 || y2<0 || x1>=wp || y1>=hp) return;
if (x1<0) x1=0;
if (x2>wp) x2=wp;
if (y1<0) y1=0;
if (y2>hp) y2=hp;
for (WORD y=y1;y<=y2;y++)
	HLine(x1,y,x2);
}

void BufferGrafico::BoxR(int x1,int y1,int x2,int y2,byte r)
{
int t;
if (y1>y2) { t=y1;y1=y2;y2=t; } // y1 arriba
if (x1>x2) { t=x1;x1=x2;x2=t; } // x1 a la izq
VLine(x1,y1+r,y2-r);
VLine(x2,y1+r,y2-r);
HLine(x1+r,y1,x2-r);
HLine(x1+r,y2,x2-r);
}

void BufferGrafico::FillBoxR(int x1,int y1,int x2,int y2,byte r)
{
int t;
if (y1>y2) { t=y1;y1=y2;y2=t; } // y1 arriba
if (x1>x2) { t=x1;x1=x2;x2=t; } // x1 a la izq
if (x2<0 || y2<0 || x1>=wp || y1>=hp) return;
byte cr=r;
WORD y=y1;
while (cr>0 && y<=y2) {
	HLine(x1+cr,y,x2-cr);
	cr--;y++;
	};
while (y<=y2-r)
	{
	HLine(x1,y,x2);
	y++;
	}
while (y<=y2) {
	cr++;
	HLine(x1+cr,y,x2-cr);
	y++;
	}
}

void BufferGrafico::Boton(int x1,int y1,int x2,int y2)
{
ColorRGBA c1,c2=color;
c1=c2;c1.mix(colorblanco,128);Color(c1);
HLine(x1,y1,x2);VLine(x1,y1,y2);
c1=c2;c1.mix(colornegro,240);Color(c1);
HLine(x1,y2,x2);VLine(x2,y1,y2);
Color(c2);FillBox(x1+1,y1+1,x2-1,y2-1);
}

void BufferGrafico::BotonD(int x1,int y1,int x2,int y2)
{
ColorRGBA c1,c2=color;
c1=c2;c1.mix(colorblanco,128);Color(c1);
HLine(x1,y1,x2);HLine(x1+1,y1+1,x2-1);
VLine(x1,y1,y2);VLine(x1+1,y1+1,y2-1);
c1=c2;c1.mix(colornegro,240);Color(c1);
HLine(x1,y2,x2);HLine(x1+1,y2-1,x2-1);
VLine(x2,y1,y2);VLine(x2-1,y1+1,y2-1);
Color(c2);FillBox(x1+2,y1+2,x2-2,y2-2);
}

void BufferGrafico::BotonP(int x1,int y1,int x2,int y2)
{
ColorRGBA c1,c2=color;
c1=c2;c1.mix(colorblanco,128);Color(c1);
HLine(x1+1,y2,x2);VLine(x2,y1,y2-1);
c1=c2;c1.mix(colornegro,240);Color(c1);
HLine(x1,y1,x2);VLine(x1,y1+1,y2);
Color(c2);FillBox(x1+1,y1+1,x2-1,y2-1);
}

void BufferGrafico::DBoton(int x1,int y1,int x2,int y2,char *t)
{
ColorRGBA c1,c2=color;
c1=c2;c1.mix(colorblanco,128);
Pantalla.FillBoxR(x1+1,y1+1,x2-1,y2-1,2);
Pantalla.Color(c1);
Pantalla.FillBoxR(x1+2,y1+2,x1+5,y2-4,2);
Pantalla.Color(0);
Pantalla.TextVC((x1+x2)>>1,1+((y1+y2)>>1),t);
}

void BufferGrafico::DBotonD(int x1,int y1,int x2,int y2,char *t)
{
ColorRGBA c1,c2=color;
c1=c2;c1.mix(colorblanco,128);
Pantalla.FillBoxR(x1+1,y1+1,x2-1,y2-1,2);
Pantalla.Color(c1);
Pantalla.FillBoxR(x2-5,y1+4,x2-2,y2-2,2);
Pantalla.Color(0);
Pantalla.TextVGC((x1+x2)>>1,1+((y1+y2)>>1),t);
}

void BufferGrafico::Circle(int x,int y,int r)
{
if (r<2)
	{
	SetPixel(x,y);
	return;
	}
int cx=0,cy=r;
int df=1-r; 
int d_e=3;
int d_se=-2*r+5;
bool cambio=false;
WORD al;
do {
	al=(iabs(df)<<8)/iabs(d_e);
	SetPixel(x+cx,y+cy);
//	SetPixelA(x+cx,y+cy,al);DecXPos();SPixelA(255-al);
	if (cx)	{ SetPixel(x-cx,y+cy);}//;IncYPos();SPixelA(255-al); }
    if (cy)	{ SetPixel(x+cx,y-cy);}//,255-al);IncXPos();SPixelA(al); }
    if ((cx) && (cy)) { SetPixel(x-cx,y-cy); }
    if (cx!=cy) 
		{
		SetPixel(x+cy,y+cx);
		if (cx) SetPixel(x+cy,y-cx);
		if (cy) SetPixel(x-cy,y+cx);
		if (cx && cy) SetPixel(x-cy,y-cx);
		}
    if (df<0)  
		{df+=d_e;d_e +=2;d_se+=2;}
	else 
		{df+=d_se;d_e+=2;d_se+=4;cy--;} 
	cx++; 
} while (cx<=cy);
}

void BufferGrafico::Ellipse(int x, int y, int rx, int ry)
{
int ix,iy;
int h,i,j,k;
int oh,oi,oj,ok;
if (rx<1) rx=1; 
if (ry<1) ry=1;
h=i=j=k=0xFFFF;
if (rx>ry) 
	{
	ix=0;iy=rx*64;
    do {
	 oh=h;oi=i;oj=j;ok=k;
	 h=(ix+32)>>6;i=(iy+32)>>6;
	 j=(h*ry)/rx;k=(i*ry)/rx;
	 if (((h!=oh)||(k!=ok))&&(h<oi)) 
		{
		SetPixel(x+h,y+k); 
	    if (h) SetPixel(x-h,y+k);
	    if (k) 
			{
			SetPixel(x+h,y-k); 
		    if (h) SetPixel(x-h,y-k);
			}
		}
	 if (((i!=oi)||(j!=oj))&&(h<i)) 
		{
	    SetPixel(x+i,y+j); 
	    if (i) SetPixel(x-i,y+j);
	    if (j) 
			{
			SetPixel(x+i,y-j); 
			if (i) SetPixel(x-i,y-j);
			}
		}
	 ix=ix+iy/rx;iy=iy-ix/rx;
     } while (i > h);
	} 
else 
	{
	ix=0;iy=ry*64;
    do {
	 oh=h;oi=i;oj=j;ok=k;
	 h=(ix+32)>>6;i=(iy+32)>>6;
	 j=(h*rx)/ry;k=(i*rx)/ry;
	 if (((j!=oj)||(i!=oi)) && (h<i)) 
		{
	    SetPixel(x+j,y+i); 
	    if (j) SetPixel(x-j,y+i);
	    if (i) 
			{
			SetPixel(x+j,y-i); 
			if (j) SetPixel(x-j,y-i);
			}
		}
	 if (((k != ok) || (h != oh)) && (h < oi)) 
		{
	    SetPixel(x+k,y+h); 
	    if (k) SetPixel(x-k,y+h);
	    if (h) 
			{
			SetPixel(x+k,y-h); 
			if (k) SetPixel(x-k,y-h);
			}
		}
	 ix=ix+iy/ry;iy=iy-ix/ry;
	} while(i > h);
	}
}
void BufferGrafico::FillCircle(int x,int y,int r)
{
if (r<1)
	{
	SetPixel(x,y);
	return;
	}
int cx=0,cy=r,cxa;
int df=1-r; 
int d_e=3;
int d_se=-2*r+5;
int c=1;
WORD al,dal,j;
byte ci;
do {
	/*
	al=abs(df)*255/(1-r);
	SetPixelA(x-cy,y-cx,al);
	SetPixelA(x-cy,y+cx,al);
	*/
	if (cy>0) HLine(x-cy+1,y+cx,x+cy-1);
	if (cx>0) HLine(x-cy+1,y-cx,x+cy-1);
    if (df<0)  
		{df+=d_e;d_e +=2;d_se+=2;c++;}
	else 
		{
		al=dal=(alpha<<8)/c;
		for (j=0;j<c;j++)
			{
			ci=al>>8;
			SetPixelA(x-cx+j,y-cy,ci);
			SetPixelA(x-cx+j,y+cy,ci);
			SetPixelA(x-cy,y+cx-j,ci);
			SetPixelA(x-cy,y-cx+j,ci);
			SetPixelA(x+cx-j,y-cy,ci);
			SetPixelA(x+cx-j,y+cy,ci);
			SetPixelA(x+cy,y+cx-j,ci);
			SetPixelA(x+cy,y-cx+j,ci);
			al+=dal;
			}
		if (cx>c && cy!=cx)
			{
			cxa=cx-c;
			HLine(x-cxa,y-cy,x+cxa);
			HLine(x-cxa,y+cy,x+cxa);
			}
		c=1;
		df+=d_se;d_e+=2;d_se+=4;cy--;
		} 
	cx++; 
} while (cx<=cy);
}

void BufferGrafico::Ellipse(int xc,int yc,int rx,int ry,bool fill)
{
if (rx<1) rx=1;
if (ry<1) ry=1;
int a2 = rx * rx;int b2 = ry * ry;
int ds = 2 * a2;int dt = 2 * b2;
int dxt =a2/sqrtc(a2 + b2);
int t=0;int s=-2*a2*ry;int d=0;
short x=xc;
short y=yc-ry;
short xs,ys,dyt;
WORD cp;
byte is,ip;
int i;
short xm1,xm2,min,max;
SetPixel(2*xc-x,y);// "End points" 
SetPixel(2*xc-x,2*yc-y);
VLine(x,y,2*yc-y);
xm1=xm2=x;
for (i=1;i<=dxt;i++)
	{
	x--;d+=t-b2;
	if (d>=0) ys=y-1;
	else if ((d-s-a2)>0)
		{
		if ((2*d-s-a2)>=0) ys=y+1; else{ys=y;y++;d-=s+a2;s+=ds;}
		}
	else {y++;ys=y+1;d-=s+a2;s+=ds;}
	t-=dt;
	cp=(iabs(d)<<8)/iabs(s);	// Calculate alpha
	is=(byte)cp;ip=255-is;
	xm1=x;xm2=2*xc-x;
	SetPixelA(x,y,ip);SetPixelA(xm2,y,ip);	//Upper half
	SetPixelA(x,2*yc-y,ip);SetPixelA(xm2,2*yc-y,ip);	// Lower half 
	if (ys!=y) 
		{
		SetPixelA(x,ys,is);SetPixelA(xm2,ys,is);
		SetPixelA(x,2*yc-ys,is);SetPixelA(xm2,2*yc-ys,is);
		}
	if (fill)
		{
		if (ys<y){min=ys+1;max=2*yc-ys-1;}else{min=y+1;max=2*yc-y-1;}
		VLine(x,min,max);VLine(2*xc-x,min,max);
		}
	}
xm1--;xm2++;
dyt=abs(y-yc);
for (i=1;i<dyt;i++)
	{
	y++;d-=s+a2;
	if (d<=0) xs=x+1;
	else if ((d+t-b2)<0)
		{
		if ((2*d+t-b2)<=0) xs=x-1; else {xs=x;x--;d+=t-b2;t-=dt;}
		}
	else {x--;xs=x-1;d+=t-b2;t-=dt;}
	s+=ds;
	cp=(iabs(d)<<8)/iabs(t);	// Calculate alpha 
	is=(byte)cp;ip=255-is;
	SetPixelA(x,y,ip);SetPixelA(2*xc-x,y,ip);	// Upper half 
	SetPixelA(x,2*yc-y,ip);SetPixelA(2*xc-x,2*yc-y,ip);	// Lower half
	if (x!=xs) 
		{
		SetPixelA(xs,y,is);SetPixelA(2*xc-xs,y,is);
		SetPixelA(xs,2*yc-y,is);SetPixelA(2*xc-xs,2*yc-y,is);
		}
	if (fill)
		{
		if (xs<x){min=xs+1;max=2*xc-xs-1;}else{min=x+1;max=2*xc-x-1;}
		HLine(min,y,xm1);HLine(xm2,y,max);
		HLine(min,2*yc-y,xm1);HLine(xm2,2*yc-y,max);
		}
	}
HLine(xc-rx,yc,xm1);HLine(xm2,yc,xc+rx);
}

const unsigned char bit[]={0x80,0x40,0x20,0x10,0x8,0x4,0x2,0x1};

int parseH(char *s)
{
int a;
if (*s>='0' && *s<='9')	a=*s-'0';
else if (*s>='A' && *s<='F') a=*s-'A'+10;
else if (*s>='a' && *s<='f') a=*s-'a'+10;
return a;
}

char *parseColor(char *t,ColorRGBA &c)
{
if (*t==0) return t;
t++;
c.set(_rgb_scale_4[parseH(t++)],_rgb_scale_4[parseH(t++)],_rgb_scale_4[parseH(t++)],255);
return t;
}

void BufferGrafico::TextList(short x1,short y1,short x2,short y2,char *l,short c)
{
ColorRGBA col1,col2;
Color(0);FillBox(x1,y1,x2,y2);//BotonP(x1,y1,x2,y2);
short cnt=ListLenC(l,'|');
if (cnt==0) return;
short i,d=10;
char *t;

col1.set(0,0,0,255);
col2.set(255,255,255,255);
for (i=0;i<cnt;i++) 
	{
	t=ListGetAtC(l,i,'|');
	Color((i==c)?col2:col1);
	FillBox(x1,y1,x2,y1+d-1);
	Color((i==c)?col1:col2);
	TextV(x1,y1+1,t);
	y1+=d;
	if (y1>y2) return;
	}
}


char *parseXY(char *t,short &x,short &y)
{
if (*t==0) return t;
t++;
x=0;
while (*t>='0' && *t<='9') {
	x=x*10+(*t-'0');
	t++;
	};
t++;
y=0;
while (*t>='0' && *t<='9') {
	y=y*10+(*t-'0');
	t++;
	};
return t-1;
}


void superdraw(short x1,short y1,short x2,short y2,char *t)
{
//char tt[90];
ColorRGBA c;
short x,y,xa,ya,xb,yb;
//char *i;
while (*t!=0 && *t!='|') {
	switch (*t) {
	case '#':// color
		t=parseColor(t,c);
		Pantalla.Color(c);
		break;
	case 't':// texto
		t++;//i=t;
		Pantalla.TextSizeV(t,&x,&y);
		x>>=1;y>>=1;
		x=((x1+x2)>>1)-x;y=((y1+y2)>>1)-y;
		Pantalla.TextV(x+1,y+1,t);
		while (*t!=0 && *t!='|') t++;
		t--;
		break;
	case 'l':// linea
		t=parseXY(t,xa,ya);t++;
		t=parseXY(t,xb,yb);
		xa=xa*(x2-x1)/100+x1;ya=ya*(y2-y1)/100+y1;
		xb=xb*(x2-x1)/100+x1;yb=yb*(y2-y1)/100+y1;
		Pantalla.Line(xa,ya,xb,yb);
		break;
	case 'p':// poligono
	case 'c':// circulo
	case 'e':// ellipse
		t=parseXY(t,xa,ya);t++;
		t=parseXY(t,xb,yb);
		xa=xa*(x2-x1)/100+x1;ya=ya*(y2-y1)/100+y1;
		xb=xb*(x2-x1)/100;yb=yb*(y2-y1)/100;
		//Pantalla.Circle(xa,ya,xb);
		if (xb<1) xb=1;
		if (yb<1) yb=1;
		if (xb>12) xb=12;
		if (yb>12) yb=12;
		Pantalla.Ellipse(xa,ya,xb,yb,true);
		break;	
	case 'b':// caja
		t=parseXY(t,xa,ya);t++;
		t=parseXY(t,xb,yb);
		//sprintf(tt,"%i,%i %i,%i",xa,ya,xb,yb);
		xa=xa*(x2-x1)/100+x1;ya=ya*(y2-y1)/100+y1;
		xb=xb*(x2-x1)/100+x1;yb=yb*(y2-y1)/100+y1;
		Pantalla.FillBox(xa,ya,xb,yb);
		//Pantalla.Text(xa,ya,tt);
		break;
	case 'u':// boton
		Pantalla.Boton(x1,y1,x2,y2);
		break;
	};
	t++;
	}
}

const unsigned char fontv12[] = {
1,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x40,0x00,0x00,//!
4,0x00,0x48,0x48,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//34
6,0x00,0x24,0x24,0x7E,0x24,0x24,0x24,0x7E,0x24,0x24,0x00,0x00,//35
5,0x00,0x10,0x38,0x54,0x50,0x30,0x18,0x14,0x54,0x38,0x10,0x00,//36
7,0x00,0x30,0x49,0x32,0x04,0x08,0x10,0x26,0x49,0x06,0x00,0x00,
5,0x00,0x20,0x50,0x50,0x20,0x20,0x54,0x48,0x48,0x34,0x00,0x00,
1,0x00,0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//'
2,0x00,0x20,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x20,
2,0x00,0x40,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x40,
3,0x00,0x00,0x50,0x20,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x10,0x10,0x7C,0x10,0x10,0x00,0x00,0x00,
2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40,0x00,
2,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,//-
2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,
4,0x00,0x08,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x00,0x00,
5,0x00,0x38,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x38,0x00,0x00,
3,0x00,0x10,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,
5,0x00,0x38,0x44,0x04,0x04,0x08,0x10,0x20,0x40,0x7C,0x00,0x00,
5,0x00,0x38,0x44,0x04,0x04,0x18,0x04,0x04,0x44,0x38,0x00,0x00,
5,0x00,0x08,0x18,0x18,0x28,0x28,0x48,0x7C,0x08,0x08,0x00,0x00,
5,0x00,0x7C,0x40,0x40,0x78,0x44,0x04,0x04,0x44,0x38,0x00,0x00,
5,0x00,0x38,0x44,0x40,0x40,0x78,0x44,0x44,0x44,0x38,0x00,0x00,
5,0x00,0x7C,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x20,0x00,0x00,
5,0x00,0x38,0x44,0x44,0x44,0x38,0x44,0x44,0x44,0x38,0x00,0x00,
5,0x00,0x38,0x44,0x44,0x44,0x3C,0x04,0x04,0x44,0x38,0x00,0x00,
2,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x40,0x00,0x00,
2,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x20,0x40,0x00,
4,0x00,0x00,0x00,0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x00,0x7C,0x00,0x7C,0x00,0x00,0x00,0x00,
4,0x00,0x00,0x00,0x40,0x20,0x10,0x08,0x10,0x20,0x40,0x00,0x00,
5,0x00,0x38,0x44,0x04,0x04,0x08,0x10,0x10,0x00,0x10,0x00,0x00,
5,0x00,0x00,0x38,0x44,0x44,0x5c,0x5c,0x58,0x40,0x40,0x38,0x00,// 64
//8,0x00,0x0F,0x30,0x20,0x47,0x49,0x49,0x46,0x20,0x30,0x0F,0x00,//64 10 @
6,0x00,0x10,0x10,0x28,0x28,0x44,0x44,0x7C,0x82,0x82,0x00,0x00,//A
5,0x00,0x78,0x44,0x44,0x44,0x78,0x44,0x44,0x44,0x78,0x00,0x00,
6,0x00,0x3C,0x42,0x40,0x40,0x40,0x40,0x40,0x42,0x3C,0x00,0x00,
6,0x00,0x78,0x44,0x42,0x42,0x42,0x42,0x42,0x44,0x78,0x00,0x00,
5,0x00,0x7C,0x40,0x40,0x40,0x78,0x40,0x40,0x40,0x7C,0x00,0x00,
5,0x00,0x7C,0x40,0x40,0x40,0x78,0x40,0x40,0x40,0x40,0x00,0x00,
6,0x00,0x3C,0x42,0x40,0x40,0x4E,0x42,0x42,0x46,0x3A,0x00,0x00,//G
6,0x00,0x42,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0x00,0x00,
2,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
3,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x90,0x90,0x60,0x00,0x00,
6,0x00,0x44,0x48,0x50,0x60,0x60,0x50,0x48,0x44,0x42,0x00,0x00,
5,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7C,0x00,0x00,
7,0x00,0x41,0x41,0x63,0x63,0x55,0x55,0x49,0x49,0x41,0x00,0x00,
6,0x00,0x42,0x62,0x62,0x52,0x52,0x4A,0x46,0x46,0x42,0x00,0x00,
6,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
6,0x00,0x7C,0x42,0x42,0x42,0x7C,0x40,0x40,0x40,0x40,0x00,0x00,
6,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x4A,0x46,0x3C,0x02,0x00,
6,0x00,0x7C,0x42,0x42,0x42,0x7C,0x42,0x42,0x42,0x42,0x00,0x00,
5,0x00,0x38,0x44,0x40,0x40,0x38,0x04,0x04,0x44,0x38,0x00,0x00,
5,0x00,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,
6,0x00,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
6,0x00,0x82,0x82,0x44,0x44,0x44,0x28,0x28,0x10,0x10,0x00,0x00,
7,0x00,0x41,0x41,0x41,0x41,0x22,0x2A,0x2A,0x2A,0x14,0x00,0x00,//87 W
//8,0x00,0x80,0x80,0x44,0x44,0x44,0x2A,0x2A,0x11,0x11,0x00,0x00,//87 10W
7,0x00,0x41,0x41,0x22,0x14,0x08,0x14,0x22,0x41,0x41,0x00,0x00,//88 X
6,0x00,0x82,0x82,0x44,0x28,0x10,0x10,0x10,0x10,0x10,0x00,0x00,
6,0x00,0xFE,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0xFE,0x00,0x00,
2,0x00,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x60,
4,0x00,0x40,0x40,0x40,0x20,0x20,0x10,0x10,0x08,0x08,0x00,0x00,
2,0x00,0x60,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x60,
5,0x10,0x28,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,
2,0x00,0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x38,0x04,0x3C,0x44,0x44,0x3C,0x00,0x00,
5,0x00,0x40,0x40,0x40,0x78,0x44,0x44,0x44,0x44,0x78,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x38,0x44,0x40,0x40,0x44,0x38,0x00,0x00,
5,0x00,0x04,0x04,0x04,0x3C,0x44,0x44,0x44,0x44,0x3C,0x00,0x00,//100 d
5,0x00,0x00,0x00,0x00,0x38,0x44,0x7C,0x40,0x44,0x38,0x00,0x00,//101 e
2,0x00,0x20,0x40,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x00,0x00,//102
5,0x00,0x00,0x00,0x00,0x3C,0x44,0x44,0x44,0x44,0x3C,0x04,0x78,//103
5,0x00,0x40,0x40,0x40,0x58,0x64,0x44,0x44,0x44,0x44,0x00,0x00,//104 h
1,0x00,0x40,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,//105 i
2,0x00,0x40,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,//106 j
5,0x00,0x40,0x40,0x40,0x48,0x50,0x60,0x50,0x48,0x44,0x00,0x00,//107 k
1,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,//108
7,0x00,0x00,0x00,0x00,0x76,0x49,0x49,0x49,0x49,0x49,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x58,0x64,0x44,0x44,0x44,0x44,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x38,0x44,0x44,0x44,0x44,0x38,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x78,0x44,0x44,0x44,0x44,0x78,0x40,0x40,
5,0x00,0x00,0x00,0x00,0x3C,0x44,0x44,0x44,0x44,0x3C,0x04,0x04,
2,0x00,0x00,0x00,0x00,0x60,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
4,0x00,0x00,0x00,0x00,0x30,0x48,0x20,0x10,0x48,0x30,0x00,0x00,
2,0x00,0x00,0x40,0x40,0x60,0x40,0x40,0x40,0x40,0x20,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x44,0x44,0x44,0x44,0x4C,0x34,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x44,0x44,0x28,0x28,0x10,0x10,0x00,0x00,
7,0x00,0x00,0x00,0x00,0x49,0x49,0x55,0x55,0x22,0x22,0x00,0x00,
4,0x00,0x00,0x00,0x00,0x48,0x48,0x30,0x30,0x48,0x48,0x00,0x00,
4,0x00,0x00,0x00,0x00,0x48,0x48,0x48,0x48,0x30,0x20,0x20,0xC0,
4,0x00,0x00,0x00,0x00,0x78,0x08,0x10,0x20,0x40,0x78,0x00,0x00,
3,0x10,0x20,0x20,0x20,0x20,0x40,0x20,0x20,0x20,0x20,0x10,0x00,
2,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,
3,0x40,0x20,0x20,0x20,0x20,0x10,0x20,0x20,0x20,0x20,0x40,0x00,// 125 }
6,0x00,0x00,0x32,0x4C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 126 ~
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,// 127 ¦
5,0x00,0x38,0x44,0x44,0xF0,0x40,0xE0,0x44,0x44,0x38,0x00,0x00,// 128 Ç
7,0x00,0x00,0x10,0x10,0x38,0x38,0x7c,0x7c,0xfe,0xfe,0x00,0x00,//
7,0x00,0x00,0xfe,0xfe,0x7c,0x7c,0x38,0x38,0x10,0x10,0x00,0x00,//
2,0x00,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x00,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x00,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x00,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x20,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
2,0x00,0x00,0x20,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,
2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
2,0x00,0x00,0x00,0x40,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
5,0x00,0x00,0x00,0x08,0x38,0x44,0x40,0x40,0x44,0x38,0x20,0x00,
5,0x00,0x30,0x48,0x40,0x20,0x70,0x20,0x40,0x40,0x7C,0x00,0x00,
5,0x00,0x44,0x38,0x44,0x44,0x44,0x38,0x44,0x00,0x00,0x00,0x00,
5,0x00,0x44,0x44,0x44,0x28,0x7C,0x10,0x7C,0x10,0x10,0x00,0x00,
2,0x00,0x40,0x40,0x40,0x40,0x40,0x00,0x40,0x40,0x40,0x40,0x40,
5,0x00,0x38,0x44,0x20,0x50,0x48,0x24,0x14,0x08,0x44,0x38,0x00,
2,0x00,0x00,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
8,0x00,0x1E,0x21,0x4C,0x50,0x4C,0x21,0x1E,0x00,0x00,0x00,0x00,
3,0x00,0x60,0x30,0x50,0x70,0x00,0x70,0x00,0x00,0x00,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x00,0x14,0x28,0x50,0x28,0x14,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x04,0x00,0x00,0x00,0x00,
2,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,
7,0x00,0x1C,0x22,0x5D,0x59,0x55,0x22,0x1C,0x00,0x00,0x00,0x00,
5,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
3,0x00,0x20,0x50,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
5,0x00,0x00,0x00,0x10,0x10,0x7C,0x10,0x10,0x00,0x7C,0x00,0x00,
2,0x00,0xC0,0x20,0x40,0x80,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,
2,0x00,0xC0,0x20,0x40,0x20,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
2,0x00,0x20,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x48,0x48,0x48,0x48,0x48,0x74,0x40,0x40,
5,0x00,0x3C,0x7C,0x7C,0x7C,0x3C,0x14,0x14,0x14,0x14,0x14,0x00,
2,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x60,
2,0x00,0x20,0x60,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,
3,0x00,0x70,0x50,0x50,0x70,0x00,0x70,0x00,0x00,0x00,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x00,0x50,0x28,0x14,0x28,0x50,0x00,0x00,
7,0x00,0x20,0x61,0x22,0x24,0x29,0x13,0x25,0x47,0x01,0x00,0x00,
7,0x00,0x20,0x61,0x22,0x24,0x2E,0x11,0x22,0x44,0x07,0x00,0x00,
7,0x00,0x60,0x11,0x22,0x14,0x69,0x13,0x25,0x47,0x01,0x00,0x00,
5,0x00,0x00,0x00,0x10,0x00,0x10,0x10,0x20,0x40,0x40,0x44,0x38,
6,0x10,0x10,0x10,0x28,0x28,0x44,0x44,0x7C,0x82,0x82,0x00,0x00,
6,0x10,0x10,0x10,0x28,0x28,0x44,0x44,0x7C,0x82,0x82,0x00,0x00,
6,0x28,0x00,0x10,0x28,0x28,0x44,0x44,0x7C,0x82,0x82,0x00,0x00,
6,0x58,0x10,0x10,0x28,0x28,0x44,0x44,0x7C,0x82,0x82,0x00,0x00,
6,0x00,0x10,0x10,0x28,0x28,0x44,0x44,0x7C,0x82,0x82,0x00,0x00,
6,0x28,0x10,0x10,0x28,0x28,0x44,0x44,0x7C,0x82,0x82,0x00,0x00,
8,0x00,0x1F,0x18,0x28,0x28,0x4F,0x78,0x48,0x88,0x8F,0x00,0x00,
6,0x00,0x3C,0x42,0x40,0x40,0x40,0x40,0x40,0x42,0x3C,0x08,0x18,
5,0x10,0x7C,0x40,0x40,0x40,0x78,0x40,0x40,0x40,0x7C,0x00,0x00,
5,0x10,0x7C,0x40,0x40,0x40,0x78,0x40,0x40,0x40,0x7C,0x00,0x00,
5,0x28,0x7C,0x40,0x40,0x40,0x78,0x40,0x40,0x40,0x7C,0x00,0x00,
5,0x00,0x7C,0x40,0x40,0x40,0x78,0x40,0x40,0x40,0x7C,0x00,0x00,
2,0x40,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
2,0x40,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
2,0xA0,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
2,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
6,0x00,0x78,0x44,0x42,0x42,0xF2,0x42,0x42,0x44,0x78,0x00,0x00,
6,0x4C,0x42,0x62,0x62,0x52,0x52,0x4A,0x46,0x46,0x42,0x00,0x00,
6,0x08,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
6,0x10,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
6,0x24,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
6,0x4C,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
6,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x44,0x28,0x10,0x28,0x44,0x00,0x00,0x00,
6,0x00,0x3E,0x46,0x4A,0x4A,0x52,0x52,0x62,0x62,0x7C,0x00,0x00,
6,0x08,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
6,0x10,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
6,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
6,0x00,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
6,0x10,0x82,0x82,0x44,0x28,0x10,0x10,0x10,0x10,0x10,0x00,0x00,
6,0x00,0x40,0x40,0x7C,0x42,0x42,0x42,0x7C,0x40,0x40,0x00,0x00,
5,0x00,0x30,0x48,0x48,0x48,0x58,0x44,0x44,0x44,0x58,0x00,0x00,
5,0x00,0x20,0x10,0x00,0x38,0x04,0x3C,0x44,0x44,0x3C,0x00,0x00,
5,0x00,0x08,0x10,0x00,0x38,0x04,0x3C,0x44,0x44,0x3C,0x00,0x00,
5,0x00,0x10,0x28,0x00,0x38,0x04,0x3C,0x44,0x44,0x3C,0x00,0x00,
5,0x00,0x34,0x58,0x00,0x38,0x04,0x3C,0x44,0x44,0x3C,0x00,0x00,
5,0x00,0x24,0x00,0x00,0x38,0x04,0x3C,0x44,0x44,0x3C,0x00,0x00,
5,0x10,0x28,0x10,0x00,0x38,0x04,0x3C,0x44,0x44,0x3C,0x00,0x00,
9,0x00,0x00,0x00,0x00,0x3B,0x04,0x3F,0x44,0x44,0x3B,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x38,0x44,0x40,0x40,0x44,0x38,0x10,0x30,
5,0x00,0x20,0x10,0x00,0x38,0x44,0x7C,0x40,0x44,0x38,0x00,0x00,
5,0x00,0x08,0x10,0x00,0x38,0x44,0x7C,0x40,0x44,0x38,0x00,0x00,
5,0x00,0x10,0x28,0x00,0x38,0x44,0x7C,0x40,0x44,0x38,0x00,0x00,
5,0x00,0x44,0x00,0x00,0x38,0x44,0x7C,0x40,0x44,0x38,0x00,0x00,
2,0x00,0x80,0x40,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
3,0x00,0x10,0x20,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,
3,0x00,0x20,0x50,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,
3,0x00,0x50,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,
5,0x00,0x28,0x10,0x28,0x08,0x3C,0x44,0x44,0x44,0x38,0x00,0x00,
5,0x00,0x34,0x58,0x00,0x58,0x64,0x44,0x44,0x44,0x44,0x00,0x00,
5,0x00,0x20,0x10,0x00,0x38,0x44,0x44,0x44,0x44,0x38,0x00,0x00,
5,0x00,0x08,0x10,0x00,0x38,0x44,0x44,0x44,0x44,0x38,0x00,0x00,
5,0x00,0x10,0x28,0x00,0x38,0x44,0x44,0x44,0x44,0x38,0x00,0x00,
5,0x00,0x34,0x58,0x00,0x38,0x44,0x44,0x44,0x44,0x38,0x00,0x00,
5,0x00,0x44,0x00,0x00,0x38,0x44,0x44,0x44,0x44,0x38,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x10,0x00,0x7C,0x00,0x10,0x00,0x00,0x00,
5,0x00,0x00,0x00,0x00,0x3C,0x4C,0x54,0x54,0x64,0x78,0x00,0x00,
5,0x00,0x20,0x10,0x00,0x44,0x44,0x44,0x44,0x4C,0x34,0x00,0x00,
5,0x00,0x08,0x10,0x00,0x44,0x44,0x44,0x44,0x4C,0x34,0x00,0x00,
5,0x00,0x10,0x28,0x00,0x44,0x44,0x44,0x44,0x4C,0x34,0x00,0x00,
5,0x00,0x44,0x00,0x00,0x44,0x44,0x44,0x44,0x4C,0x34,0x00,0x00,
4,0x00,0x10,0x20,0x00,0x48,0x48,0x48,0x48,0x30,0x20,0x20,0xC0,
5,0x00,0x40,0x40,0x40,0x78,0x44,0x44,0x44,0x44,0x78,0x40,0x40,
4,0x00,0x48,0x00,0x00,0x48,0x48,0x48,0x48,0x30,0x20,0x20,0xC0};

char BufferGrafico::wCharV(short x,short y,unsigned char c)
{
if (c<33) return 4;
const unsigned char *car=&fontv12[(c-33)*13];
char i,j,cnt=(*car)+1;
car++;
for (i=0;i<12;i++,car++,y++)
  for (j=0;j<cnt;j++)
    if (*car&bit[j]) Pantalla.SetPixel(x+j,y);
return cnt;
}

char BufferGrafico::wCharVB(short x,short y,unsigned char c)
{
if (c<33) return 4;
const unsigned char *car=&fontv12[(c-33)*13];
char i,j,cnt=(*car)+1;
car++;
for (i=0;i<12;i++,car++,y++)
  for (j=0;j<cnt;j++)
    if (*car&bit[j]) FillBox(x+j-1,y-1,x+j+1,y+1);
return cnt;
}

char BufferGrafico::wCharVG(short x,short y,unsigned char c)
{
if (c<33) return 4;
const unsigned char *car=&fontv12[(c-33)*13];
char i,j,cnt=(*car)+1;
car++;
for (i=0;i<12;i++,car++,y++)
  for (j=0;j<cnt;j++)
    if (*car&bit[j]) HLine(x+j,y,x+j+1);
return cnt;
}
		
void BufferGrafico::TextSizeV(char *n,short *x,short *y)
{
char cnt;
*x=0;
*y=12;
//for (;*n!=0&&*n!='|';n++,*x+=6);
for (;*n!=0;n++)
	{
	cnt=4;
	if (*n<33) cnt=4; else cnt=fontv12[(((unsigned char)*n)-33)*13]+1;	
	*x+=cnt;
	}
}

void BufferGrafico::TextV(short x,short y,char *n)
{
char cnt;
for (;*n!=0;n++)
	{
	cnt=wCharV(x,y,(unsigned char)*n);
	x+=cnt;
	}
}

void BufferGrafico::TextVG(short x,short y,char *n)
{
char cnt;
for (;*n!=0;n++)
	{
	cnt=wCharVG(x,y,(unsigned char)*n);
	x+=cnt+1;
	}
}

void BufferGrafico::TextVB(short x,short y,char *n)
{
char cnt;
for (;*n!=0;n++)
	{
	cnt=wCharVB(x,y,(unsigned char)*n);
	x+=cnt;
	}
}

void BufferGrafico::TextVC(short x,short y,char *n)
{
short lx,ly;
TextSizeV(n,&lx,&ly);
TextV(x-(lx>>1),y-(ly>>1),n);
}

void BufferGrafico::TextVBC(short x,short y,char *n)
{
short lx,ly;
TextSizeV(n,&lx,&ly);
TextVB(x-(lx>>1),y-(ly>>1),n);
}

void BufferGrafico::TextVGC(short x,short y,char *n)
{
short lx,ly;
TextSizeV(n,&lx,&ly);
lx+=strlen(n);//1 por letra
TextVG(x-(lx>>1),y-(ly>>1),n);
}

//--------------- 2x
char BufferGrafico::wCharV2(short x,short y,unsigned char c)
{
if (c<33) return 4;
const unsigned char *car=&fontv12[(c-33)*13];
char i,j,cnt=(*car)+1;
car++;
for (i=0;i<12;i++,car++,y+=2)
  for (j=0;j<cnt;j++)
    if (*car&bit[j]) FillBox(x+2*j,y,x+2*j+1,y+1);
return cnt;
}

char BufferGrafico::wCharVB2(short x,short y,unsigned char c)
{
if (c<33) return 4;
const unsigned char *car=&fontv12[(c-33)*13];
char i,j,cnt=(*car)+1;
car++;
for (i=0;i<12;i++,car++,y+=2)
  for (j=0;j<cnt;j++)
    if (*car&bit[j]) FillBox(x+2*j-1,y-1,x+2*j+3,y+3);
return cnt;
}
		
void BufferGrafico::TextSizeV2(char *n,short *x,short *y)
{
char cnt;
*x=0;
*y=12*2;
//for (;*n!=0&&*n!='|';n++,*x+=6);
for (;*n!=0;n++)
	{
	cnt=4;
	if (*n<33) cnt=4; else cnt=fontv12[(((unsigned char)*n)-33)*13]+1;	
	*x+=cnt*2;
	}
}

void BufferGrafico::TextV2(short x,short y,char *n)
{
char cnt;
for (;*n!=0;n++)
	{
	cnt=wCharV2(x,y,(unsigned char)*n);
	x+=cnt*2;
	}
}

void BufferGrafico::TextVB2(short x,short y,char *n)
{
char cnt;
for (;*n!=0;n++)
	{
	cnt=wCharVB2(x,y,(unsigned char)*n);
	x+=cnt*2;
	}
}

void BufferGrafico::TextVC2(short x,short y,char *n)
{
short lx,ly;
TextSizeV2(n,&lx,&ly);
TextV2(x-(lx>>1),y-(ly>>1),n);
}

void BufferGrafico::TextVBC2(short x,short y,char *n)
{
short lx,ly;
TextSizeV2(n,&lx,&ly);
TextVB2(x-(lx>>1),y-(ly>>1),n);
}

#define MAX(a,b) ((a>b)?a:b)
#define MIN(a,b) ((a<b)?a:b)

#define HLSMAX 240 // H,L, and S vary over 0-HLSMAX
#define RGBMAX 255 //;			// R,G, and B vary over 0-RGBMAX
#define UNDEFINED (HLSMAX*2/3)

void RGB_to_HSL(int r,int g,int b,int *h,int *s,int *l)
{
int cMax, cMin;
int Rdelta,Gdelta,Bdelta;

cMax=MAX(r,MAX(g,b));
cMin=MIN(r,MAX(g,b));
*l=(((cMax+cMin)*HLSMAX)+RGBMAX)/(2*RGBMAX);
if (cMax==cMin) //r=g=b --> achromatic case
	{
	*s=0;*h=UNDEFINED;
	}
else
	{
	if (*l<=(HLSMAX/2))
		*s=(((cMax-cMin)*HLSMAX)+((cMax+cMin)/2))/(cMax+cMin);
	else
		*s=(((cMax-cMin)*HLSMAX)+((2*RGBMAX-cMax-cMin)/2))/(2*RGBMAX-cMax-cMin);
    Rdelta=(((cMax-r)*(HLSMAX/6))+((cMax-cMin)/2))/(cMax-cMin);
    Gdelta=(((cMax-g)*(HLSMAX/6))+((cMax-cMin)/2))/(cMax-cMin);
    Bdelta=(((cMax-b)*(HLSMAX/6))+((cMax-cMin)/2))/(cMax-cMin);
    if (r==cMax)		*h=Bdelta-Gdelta;
    else if (g==cMax)	*h=(HLSMAX/3)+Rdelta-Bdelta;
    else				*h=((2*HLSMAX)/3)+Gdelta-Rdelta;
    *h=*h%HLSMAX;
    if (*h<0) *h+=HLSMAX;
	}
}

int HueToRGB(int n1,int n2,int hue)
{
hue=hue%HLSMAX;
//hue=hue&0xff;
if (hue<0) hue+=HLSMAX;
if (hue<(HLSMAX/6))
	return (n1+(((n2-n1)*hue+(HLSMAX/12))/(HLSMAX/6)));
else if (hue<(HLSMAX/2))
	return n2;
else if (hue<((HLSMAX*2)/3))
    return (n1+(((n2-n1)*(((HLSMAX*2)/3)-hue)+(HLSMAX/12))/(HLSMAX/6)));
else
	return n1;
};

void HSL_to_RGB(int h,int s,int l,int *r,int *g,int *b)
{
int m1,m2;
if (s==0)
	{
	*b=*g=*r=(l*RGBMAX)/HLSMAX;
	}
else
	{
	if (l<=(HLSMAX/2))
		m2=(l*(HLSMAX+s)+(HLSMAX/2))/HLSMAX;
	else
		m2=l+s-((l*s)+(HLSMAX/2))/HLSMAX;
	m1=2*l-m2;
	*r=(HueToRGB(m1,m2,h+(HLSMAX/3))*RGBMAX+(HLSMAX/2))/HLSMAX;
    *g=(HueToRGB(m1,m2,h)           *RGBMAX+(HLSMAX/2))/HLSMAX;
    *b=(HueToRGB(m1,m2,h-(HLSMAX/3))*RGBMAX+(HLSMAX/2))/HLSMAX;
	}
}